/**
 *  使用方法:
 *
 *  0. 在项目根目录的 local.properties 文件里必须填写 nexus.url、nexus.username、nexus.pwd 三个参数, 建议也填写上 group 参数.
 *  1. 将 publish_to_maven.gradle 文件保存在项目的 gradle 目录中
 *  2. 在 library 的 build.gradle 中引用 publish_to_maven.gradle 脚本插件, 如下:

 apply from: rootProject.file('gradle/publish_to_maven.gradle')

 3. 在 library 中新建 local.properties 文件 (可选操作,), local.properties 可填写如下几个参数:

 group=com.mrcd         # lib的 group, 如果没有填则使用根目录local.properties中的 group 参数, 如果该值为空, 会抛出异常!
 libName=volley         # lib 的名称
 libVersion=1.0.1       # lib 的版本号
 libFormat=aar或者jar    # lib 的格式
 libDesc=lib的作用描述
 libWebsite=lib的官方网站

 4. 执行 gradle 任务 publishToNexus
 *
 */


apply plugin: 'maven'
apply plugin: 'signing'


final String POM_LICENCE_NAME = "GNU General Public License, Version 3.0"
final String POM_LICENCE_URL = "https://www.gnu.org/licenses/gpl-3.0.txt"
final String POM_LICENCE_DIST = "repo"


def isEmpty(String text) {
    return text == null || text.length() == 0
}

def isSnapshotBuild(String versionName) {
    return versionName != null && versionName.contains("SNAPSHOT")
}

final Properties rootProperties = new Properties()
rootProperties.load(project.rootProject.file('local.properties').newDataInputStream())

// 账户信息, 存在工程根目录的 local.properties 中
final String nexusUrl = rootProperties.getProperty("nexus.url")
final String snapshotNexusUrl = rootProperties.getProperty("nexus.snapshotUrl")
final String userName = rootProperties.getProperty("nexus.username")
final String password = rootProperties.getProperty("nexus.pwd")
def groupId = rootProperties.getProperty("group")

println("\n\n=======> nexus url : " + nexusUrl + ", userName : " + userName + "\n\n" + ", current project : " + project.getName() + "\n\n")


afterEvaluate { project ->

    println("\n\n=========================================================\n\n")
    println('afterEvaluate project -> ' + project.getName())
    // library 的 local.properties 保存着 lib 下的相关信息
    final Properties libProperties = new Properties()
    File propFile = project.file('local.properties')
    println("project path : " + propFile)
    println("===========================================\n\n")
    if( propFile != null && propFile.exists() ) {
        libProperties.load(propFile.newDataInputStream())
    }

    // 从 lib 中再取一遍, 优先使用 lib 中的 group 参数
    def libGroup = libProperties.getProperty("group")
    if ( !isEmpty(libGroup) ) {
        groupId = libGroup
    }

    if ( isEmpty(groupId) ) {
        throw new IllegalArgumentException("Attention! Your library's group not set yet! ")
    }

    final String libName = libProperties.getProperty("libName", project.getName())
    final String libVersion = libProperties.getProperty("libVersion", android.defaultConfig.versionName)
    final String libDesc = libProperties.getProperty("libDesc", "no description for this library")
    final String libFormat = libProperties.getProperty("libFormat", "aar")
    final String libWebsite = libProperties.getProperty("libWebsite", "www.github.com")

    println( "group : " + groupId)
    println('name : ' + libName)
    println( "version : " + libVersion)
    println( "format : " + libFormat)

    println("\n\n=========================================================\n\n")

    // 开源协议
    final String libLicence = libProperties.getProperty("libLicence", POM_LICENCE_NAME)
    final String libLicenceUrl = libProperties.getProperty("libLicenceUrl", POM_LICENCE_URL)
    final String libLicenceDist = libProperties.getProperty("libLicenceDist",POM_LICENCE_DIST)

    // ========> java & make jar file task

    // javadoc task
    task javadoc(type: Javadoc) {
        source = android.sourceSets.main.java.srcDirs
        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
        options.encoding "UTF-8"
        options.charSet 'UTF-8'
        failOnError false
    }


    // upload to maven config
    uploadArchives {
        repositories {
            mavenDeployer {
                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

                final String repoUrl = isSnapshotBuild(libVersion) ? snapshotNexusUrl : nexusUrl
                repository(url: repoUrl) {
                    authentication(userName: userName, password: password)
                }

                snapshotRepository(url: repoUrl) {
                    authentication(userName: userName, password: password)
                }

                pom.groupId = groupId
                pom.artifactId = libName
                pom.version = libVersion

                pom.project {
                    name libName
                    packaging libFormat
                    description libDesc
                    url libWebsite

                    scm {
                        url libWebsite
                        connection libWebsite
                        developerConnection libWebsite
                    }

                    licenses {
                        license {
                            name libLicence
                            url libLicenceUrl
                            distribution libLicenceDist
                        }
                    }

                    developers {
                        developer {
                            id userName
                            name userName
                        }
                    }
                }

            }
        }
    } // end of uploadArchives


    task publishToNexus(dependsOn: uploadArchives, group: 'upload') {
        doLast {
            println("\n\n===========================================")

            println("Use it in your project : \n\n" )
            println("implementation ('" + groupId + ":" + libName + ":" + libVersion + "')")

            println("===========================================\n\n")
        }
    }

    signing {
        required { !isSnapshotBuild(libVersion) && gradle.taskGraph.hasTask("uploadArchives") }
        sign configurations.archives
    }


    // clear jar
    task clearJar(type: Delete) {
        delete "build/libs/${libName}_*.jar"
    }

    // execute a command with shell
    task openDir (type:Exec){
        commandLine "open","${project.rootDir}/${project.getName()}/build/libs/"
    }

    // make
    task makeJar(type: Copy, group:'build') {
        from('build/intermediates/bundles/release/')
        into('build/libs/')
        include('classes.jar')
        def libOutputName = "${libName}_${libVersion}.jar"
        rename ('classes.jar', libOutputName)
        doLast {
            println("\n\n=====> library path : " + getDestinationDir() + File.separator + libOutputName)
        }
    }
    makeJar.dependsOn(clearJar, build, openDir)


    def plugins = project.getPlugins()
    // android application or android library
    if (plugins.hasPlugin('com.android.application') || plugins.hasPlugin('com.android.library')) {
        task androidJavadocs(type: Javadoc) {
            source = android.sourceSets.main.java.srcDirs
            exclude "**/internal/**"
            classpath += project.files(android.getBootClasspath().join(File.pathSeparator))

            // Append also the classpath and files for release library variants.
            // This fixes the javadoc warnings.
            // Copy pasta from https://github.com/novoda/bintray-release/pull/39/files
            def releaseVariant = project.android.libraryVariants.find {
                it.name.endsWith("release")
            }

            // 兼容新版的 Gradle api
            JavaCompile javaCompile = null
            if (releaseVariant.hasProperty('javaCompileProvider')) {
                //gradle 4.10.1 +
                TaskProvider<JavaCompile> provider =  releaseVariant.javaCompileProvider
                javaCompile = provider.get()
            } else {
                javaCompile = releaseVariant.hasProperty('javaCompiler') ? releaseVariant.javaCompiler : releaseVariant.javaCompile
            }

            classpath += javaCompile.classpath
            classpath += javaCompile.outputs.files

//             classpath += releaseVariant.javaCompile.classpath
//             classpath += releaseVariant.javaCompile.outputs.files

            options.encoding "UTF-8"
            options.charSet 'UTF-8'
            failOnError false
        }

        task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
            classifier = 'javadoc'
            from androidJavadocs.destinationDir
        }

        task androidSourcesJar(type: Jar) {
            classifier = 'sources'
            from android.sourceSets.main.java.sourceFiles
        }

        artifacts {
            archives androidSourcesJar
            archives androidJavadocsJar
        }
    } else {
        task sourcesJar(type: Jar, dependsOn: classes) {
            classifier = 'sources'
            from sourceSets.main.allSource
        }

        task javadocsJar(type: Jar, dependsOn: javadoc) {
            classifier = 'javadoc'
            from javadoc.destinationDir
        }

        artifacts {
            archives sourcesJar
            archives javadocsJar
        }
    }

    if (JavaVersion.current().isJava8Compatible()) {
        allprojects {
            tasks.withType(Javadoc) {
                options.addStringOption('Xdoclint:none', '-quiet')
            }
        }
    }
}