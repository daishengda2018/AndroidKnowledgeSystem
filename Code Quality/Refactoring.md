[toc]





# 3 - 坏代码的味道

## 3.1 Duplicated Code 重复的代码

重复代码会导致代码杂乱无章、而且和老鼠洞一样很难做到统一控制。

1. **在同一个类中有重复的代码:** 

   直接使用 *Extract Method* 方法提取重复的方法。

2. **两个互为兄弟关系的子类中包含相同表达式。**

   提取相同的代码后使用 *Pull Up Method* 将它推入超类。如果代码不同但是作用是相同可以选择最好的实现方式，在 *Pull Up Method*

3. **几个毫无关系的类中有重复代码。**

   这个问题的关键是要判断把 *Extract Method* 后的代码放到什么地方，如果这个方法和一种一个类联系很大就应该放到其中，都没有关系的情况下，要创建第三方类。

   ## 3.2 Long Method 过长函数

   函数过长很难进行测试、理解、以后的拓展。让小函数更好容易理解的真正关键是一个好名字，函数的长度并不一定是关键，而是函数的名字是否能到位的描述函数在做什么。

   ![image-20200412190223658](.重构读书笔记.assets/image-20200412190223658.png)

## 3.3 Large Class 过大的类

过大的类一般都不满足单一原则，其中往往就会出现太多实例变量。遇到过大的类就要考虑 *Extract Class* 和 *Extract Subclass*方法了。

这里有个技巧：先确定客户端如何使用他们，然后运用 *Extract Interface* 为每一种使用方法提炼一个接口，这或许可以帮助我们看清楚如何分解这个类。fa

## 3.4 Log parameter List 过长参数列表

不要有太长的参数列表，如果太长就把参数封装成类，但是有些场景并不希望造成”被调用对象“与”较大对象“间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也合情合理。但是注意其所引发的代价。

面对上面的问题也可以封装一个类，单独传递参数。



## 3.5 Divergent Change 发散式变化

描述：一个类被锚定了多个变化，当这些变化中的任意一个发生时，就必须对类进行修改。
解释：一个类最好只因一种变化而被修改
操作：你应该找出某特定原因而造成的所有变化，然后运用Extract Class将它们提炼到另一个类中。

## 3.6 Shotgun Surgery 散弹式修改

描述：一种变化引发程序多处的修改。
解释: 一种变化在程序中有多个锚点，并且分散在程序各处。(就像散弹一样)
需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。

操作：找出某个变化在程序中的所有锚点，并尝试使用Move Method和Move Field将它们集中到一个类中。如果没有合适的类安置这些代码，就创造一个



# 9- 简化条件表达式

## 9.6 以多态取代条件表达式 —— switch

1. 分析相关代码，分析适合抽象为 Interface 还是可以代码复用的抽象类（一开始生命为普通方法、普通类方便一步步替换实现）

2. 分析被提取类是否可以使用依赖注入的方式完成完成多态，不能就使用map完成策略模式

3. 提取需要替代的 swtich 代码块和相关代码：
   1. 如果是抽象为 Interface 就创建默认实现类并将代码提取进去，
   2. 如果是抽象为抽象类直接提取进去（但是此时类还是普通类、普通方法）

4. 开始替换：实现子类完成一个 case 中对应的代码，并在 case 中添加 Exception

5. 测试 + 步骤 4

6. 后续工作：
   1. 如果是 Interface：删除默认实现类中的 swtich 代码块，作为空实现。
   2. 如果是抽象类：在删除 swtich 代码块后，将方法和类都改为 abstract
7. 完成工作。安全又可靠的完成。

